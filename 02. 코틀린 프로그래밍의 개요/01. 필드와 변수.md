# 필드와 변수
코틀린에서는 다음과 같은 구문으로 필드(field)를 선언하고 초기화한다.
```kotlin
val name: String = "Frank 현석 Oh"
```
자바와의 차이점을 살펴보면 다음과 같다.
- val 이라는 키워드가 맨 앞에 나온다. 이 키워드는 뒤에 오는 name이 불변(자바 final에 해당)임을 뜻한다.
- 타입이 필드 이름 뒤에 온다. 이때 이름과 타입을 콜론으로 구분한다.
- 한 문장이 끝나는 부분에 세미콜론을 붙이지 않는다. 세미콜론을 사용해도 되지만, 줄 끝이 세미콜론과 같기에 꼭 쓸 필요는 없다.

## 2.1.1 타입을 생략해 더 간단하게 만들기
위에서 작성한 코드를 더 간단하게 적을 수 있다.
```kotlin
val name = "Frank 현석 Oh"
```
이 경우, 코틀린은 필드를 초기화하는값을 보고 변수의 타입을 추측한다.  
이런 과정을 **타입 추론**(type inference)이라고 한다.  
타입 추론이 있어서 타입을 생략해도 될 때가 많지만, 타입 추론이 제대로 작동하지 않는 경우도 있다.  
예를 들어 타입이 모호하거나 필드를 값으로 초기화하지 않는 경우에 타입 추론이 제대로 작동하지 않으므로, 이때는 타입을 반드시 명시해야 한다.  

하지만 일반적으로 타입을 지정하는 편이 더 현명하다.  
타입을 지정하면 코틀린이 추로한 타입과 개발자가 예상한 타입이 다른지 검사할 수 있다.  
이는 두 타입이 서로 일치하지 않는 경우가 생기기 때문이다.

## 2.1.2 가변 필드 사용하기
앞에서 val은 참조가 불변이라는 뜻이라고 설명했지만, 모든 참조가 불변인 것은 아니다.  
참조를 바꿀 수 없다면 일단 초기화된 참조를 더럽힐 방법이 없기 때문이다.  
마찬가지 이유로, 최대한 빨리 참조를 초기화해야 한다.  
일반적으로 코틀린은 초기화하지 않은 참조를 쓸 수 없도록 막는다.  
이 부분은 초기화하지 않은 참조를 자동으로 null로 설정하고 자유롭게 쓸 수 있게 허용하는 자바와 다르다.  

가변 참조를 사용하려면 다음과 같이 val을 var로 바꿔야 한다.
```kotlin
var name = "Frank 현석 Oh"
...
name = "Joyce 계영 Lee"
```
하지만 var 사용을 최대한 피하는 것이 낫다.  
참조가 아니라 가리키는 대상이 바뀌지 않으면 프로그램을 추론하기가 훨씬 쉽기 때문이다.

## 2.1.3 지연 초기화 이해하기
참조 초기화를 늦추기 위해 var를 사용할 수 밖에 없지만, 일단 참조를 초기화하여 값이 정해진 다음부터는 변경을 막고 싶을 때가 있다.  
초기화를 늦게 해야 하는 이유는 많지만, 가장 흔한 경우는 초기화에 비용이 많이 들어서 참조를 실제로 사용하기 전까지 절대 초기화하고 싶지 않은 경우다.

일반적인 해법은 var참조를 null로 초기화하고 나중에 의미 있는 값을 대입하는 것이다.  
이렇게 바꾼 값은 이제 거의 바뀌지 않는다.  
하지만 코틀린은 널이 될 수 있는 타입(nullable type)과 널이 될 수 없는 타입(non-nullable type)을 구분하므로 이런식의 참조를 사용하기는 힘들다.  
필드 선언 시점에는 값을 알지 못하지만, 일단 초기화되고 나면 절대 바뀌지 않는 값이 존재한다.  
이때 어쩔 수 없이 var를 사용해야 된다면 슬픈 일이다.  
이 경우 다음처럼 널이 될 수 없는 참조 대신 널이 되 수 있는 참조를 써야한다.
```kotlin
var name: String? = null
...
name = getName();
```
여기서 name이라는 참조 타입은 String?인데, 이 탑이 널이 될 수 있는 타입이다.  
널이 될 수 없는 Strin 타입을 사용하려면 다음과 같이 초기화되지 않은 참조임을 나타내는 특별한 문자열을 사용해야 한다.
```kotlin
var name: String = "초기화 되지 않음"
...
name = getName()
```
또는 name에 빈 문자열을 사용하지 못하는 것이 확실하다면 빈 문자열로 초기화되지 않은 참조를 표현할 수도 있다.  
어떤 경우든 초기화한 후 절대 값이 바뀌지 않더라도 참조 선언에 var를 사용해야 한다.  
코틀린은 더 나은 해법을 제공한다.
```kotlin
val name: String by lazy { getName() }
```
이렇게 쓰면 name 참조를 최조로 사용하는 시점에 getName() 함수를 호출한다.  
여기서 람다(lambda, 함수 값을 람다라고도 부름) 대신 함수 참조를 쓸 수 있다.
```kotlin  
val name: String by lazy(::getName)
```
name이라는 참조를 최초로 사용한다는 말은 그 참조가 가리키는 값을 사용하려고 최초로 name을 역참조(dereference)한다는 말이다.  
```kotlin
fun main(args: Array<String>) {
    val name: String by lazy { getName() }
    println("안녕1")

    val name2: String by lazy { name }
    println("안녕2")
    println(name)
    println(name2)
    println(name)
    println(name2)
}

fun getName(): String {
    println("이름 계산 중...")
    return "Frank 현석 Oh"
}
```
이 프로그램을 실행하면 다음과 같은 출력 결과가 나오게 된다.
> 안녕1  
안녕2  
이름 계산 중...  
Frank 현석 Oh    
Frank 현석 Oh    
Frank 현석 Oh    
Frank 현석 Oh  

가변 참조에 대해 지연 초기화를 사용할 수는 없지만, 가변 참조를 꼭 지연 초기화해야 한다면 lateinit 키워드를 사용할 수 있다. lateinit은 최초 사용 시 초기화되지는 않지만, 어떤 면에서는 by lazy와 같은 효과를 나타낸다.
```kotlin
lateinit var name: String
...
name = getName()
```
이런 식으로 구성하면 널이 될 수 있는 타입을 사용하지 않아도 된다.  
하지만 프로퍼티를 다루고자 의존 관계 주입(DI, Dependency Injection) 프레임워크 등으로 외부에서 필드를 초기화를 진행하는 경우를 제외하면 by lazy와 비교할 때 장점이 전혀 없다.  
DI를 하더라도 불변 프로퍼티를 사용할 수 있으므로 언제나 생성자 기반의 의존 관계 주입을 사용하려고 노력해야 한다.